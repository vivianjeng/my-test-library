// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './mopro_example_app-ffi';
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterOptional,
  RustBuffer,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export function generateCircomProof(
  zkeyPath: string,
  circuitInputs: string,
  proofLib: ProofLib
): CircomProofResult /*throws*/ {
  return FfiConverterTypeCircomProofResult.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_generate_circom_proof(
          FfiConverterString.lower(zkeyPath),
          FfiConverterString.lower(circuitInputs),
          FfiConverterTypeProofLib.lower(proofLib),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function generateHalo2Proof(
  srsPath: string,
  pkPath: string,
  circuitInputs: Map<string, Array<string>>
): Halo2ProofResult /*throws*/ {
  return FfiConverterTypeHalo2ProofResult.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_generate_halo2_proof(
          FfiConverterString.lower(srsPath),
          FfiConverterString.lower(pkPath),
          FfiConverterMapStringArrayString.lower(circuitInputs),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function generateNoirProof(
  circuitPath: string,
  srsPath: string | undefined,
  inputs: Array<string>,
  onChain: boolean,
  vk: ArrayBuffer,
  lowMemoryMode: boolean
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_generate_noir_proof(
          FfiConverterString.lower(circuitPath),
          FfiConverterOptionalString.lower(srsPath),
          FfiConverterArrayString.lower(inputs),
          FfiConverterBool.lower(onChain),
          FfiConverterArrayBuffer.lower(vk),
          FfiConverterBool.lower(lowMemoryMode),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function getNoirVerificationKey(
  circuitPath: string,
  srsPath: string | undefined,
  onChain: boolean,
  lowMemoryMode: boolean
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_get_noir_verification_key(
          FfiConverterString.lower(circuitPath),
          FfiConverterOptionalString.lower(srsPath),
          FfiConverterBool.lower(onChain),
          FfiConverterBool.lower(lowMemoryMode),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * You can also customize the bindings by #[uniffi::export]
 * Reference: https://mozilla.github.io/uniffi-rs/latest/proc_macro/index.html
 */
export function moproHelloWorld(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_mopro_hello_world(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function verifyCircomProof(
  zkeyPath: string,
  proofResult: CircomProofResult,
  proofLib: ProofLib
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_verify_circom_proof(
          FfiConverterString.lower(zkeyPath),
          FfiConverterTypeCircomProofResult.lower(proofResult),
          FfiConverterTypeProofLib.lower(proofLib),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function verifyHalo2Proof(
  srsPath: string,
  vkPath: string,
  proof: ArrayBuffer,
  publicInput: ArrayBuffer
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_verify_halo2_proof(
          FfiConverterString.lower(srsPath),
          FfiConverterString.lower(vkPath),
          FfiConverterArrayBuffer.lower(proof),
          FfiConverterArrayBuffer.lower(publicInput),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function verifyNoirProof(
  circuitPath: string,
  proof: ArrayBuffer,
  onChain: boolean,
  vk: ArrayBuffer,
  lowMemoryMode: boolean
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeMoproError.lift.bind(
        FfiConverterTypeMoproError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_mopro_example_app_fn_func_verify_noir_proof(
          FfiConverterString.lower(circuitPath),
          FfiConverterArrayBuffer.lower(proof),
          FfiConverterBool.lower(onChain),
          FfiConverterArrayBuffer.lower(vk),
          FfiConverterBool.lower(lowMemoryMode),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type CircomProof = {
  a: G1;
  b: G2;
  c: G1;
  protocol: string;
  curve: string;
};

/**
 * Generated factory for {@link CircomProof} record objects.
 */
export const CircomProof = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CircomProof, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CircomProof}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CircomProof}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mopro_example_app} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CircomProof>,
  });
})();

const FfiConverterTypeCircomProof = (() => {
  type TypeName = CircomProof;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        a: FfiConverterTypeG1.read(from),
        b: FfiConverterTypeG2.read(from),
        c: FfiConverterTypeG1.read(from),
        protocol: FfiConverterString.read(from),
        curve: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeG1.write(value.a, into);
      FfiConverterTypeG2.write(value.b, into);
      FfiConverterTypeG1.write(value.c, into);
      FfiConverterString.write(value.protocol, into);
      FfiConverterString.write(value.curve, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeG1.allocationSize(value.a) +
        FfiConverterTypeG2.allocationSize(value.b) +
        FfiConverterTypeG1.allocationSize(value.c) +
        FfiConverterString.allocationSize(value.protocol) +
        FfiConverterString.allocationSize(value.curve)
      );
    }
  }
  return new FFIConverter();
})();

export type CircomProofResult = {
  proof: CircomProof;
  inputs: Array<string>;
};

/**
 * Generated factory for {@link CircomProofResult} record objects.
 */
export const CircomProofResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CircomProofResult, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CircomProofResult}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CircomProofResult}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mopro_example_app} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CircomProofResult>,
  });
})();

const FfiConverterTypeCircomProofResult = (() => {
  type TypeName = CircomProofResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        proof: FfiConverterTypeCircomProof.read(from),
        inputs: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeCircomProof.write(value.proof, into);
      FfiConverterArrayString.write(value.inputs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeCircomProof.allocationSize(value.proof) +
        FfiConverterArrayString.allocationSize(value.inputs)
      );
    }
  }
  return new FFIConverter();
})();

export type G1 = {
  x: string;
  y: string;
  z: string;
};

/**
 * Generated factory for {@link G1} record objects.
 */
export const G1 = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<G1, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link G1}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link G1}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mopro_example_app} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<G1>,
  });
})();

const FfiConverterTypeG1 = (() => {
  type TypeName = G1;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        x: FfiConverterString.read(from),
        y: FfiConverterString.read(from),
        z: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.x, into);
      FfiConverterString.write(value.y, into);
      FfiConverterString.write(value.z, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.x) +
        FfiConverterString.allocationSize(value.y) +
        FfiConverterString.allocationSize(value.z)
      );
    }
  }
  return new FFIConverter();
})();

export type G2 = {
  x: Array<string>;
  y: Array<string>;
  z: Array<string>;
};

/**
 * Generated factory for {@link G2} record objects.
 */
export const G2 = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<G2, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link G2}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link G2}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mopro_example_app} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<G2>,
  });
})();

const FfiConverterTypeG2 = (() => {
  type TypeName = G2;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        x: FfiConverterArrayString.read(from),
        y: FfiConverterArrayString.read(from),
        z: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayString.write(value.x, into);
      FfiConverterArrayString.write(value.y, into);
      FfiConverterArrayString.write(value.z, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayString.allocationSize(value.x) +
        FfiConverterArrayString.allocationSize(value.y) +
        FfiConverterArrayString.allocationSize(value.z)
      );
    }
  }
  return new FFIConverter();
})();

export type Halo2ProofResult = {
  proof: ArrayBuffer;
  inputs: ArrayBuffer;
};

/**
 * Generated factory for {@link Halo2ProofResult} record objects.
 */
export const Halo2ProofResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Halo2ProofResult, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Halo2ProofResult}, with defaults specified
     * in Rust, in the {@link mopro_example_app} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link mopro_example_app} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Halo2ProofResult>,
  });
})();

const FfiConverterTypeHalo2ProofResult = (() => {
  type TypeName = Halo2ProofResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        proof: FfiConverterArrayBuffer.read(from),
        inputs: FfiConverterArrayBuffer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.proof, into);
      FfiConverterArrayBuffer.write(value.inputs, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(value.proof) +
        FfiConverterArrayBuffer.allocationSize(value.inputs)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: MoproError

// Enum: MoproError
export enum MoproError_Tags {
  CircomError = 'CircomError',
  Halo2Error = 'Halo2Error',
  NoirError = 'NoirError',
}
export const MoproError = (() => {
  type CircomError__interface = {
    tag: MoproError_Tags.CircomError;
    inner: Readonly<[string]>;
  };

  class CircomError_ extends UniffiError implements CircomError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MoproError';
    readonly tag = MoproError_Tags.CircomError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('MoproError', 'CircomError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): CircomError_ {
      return new CircomError_(v0);
    }

    static instanceOf(obj: any): obj is CircomError_ {
      return obj.tag === MoproError_Tags.CircomError;
    }

    static hasInner(obj: any): obj is CircomError_ {
      return CircomError_.instanceOf(obj);
    }

    static getInner(obj: CircomError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Halo2Error__interface = {
    tag: MoproError_Tags.Halo2Error;
    inner: Readonly<[string]>;
  };

  class Halo2Error_ extends UniffiError implements Halo2Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MoproError';
    readonly tag = MoproError_Tags.Halo2Error;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('MoproError', 'Halo2Error');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Halo2Error_ {
      return new Halo2Error_(v0);
    }

    static instanceOf(obj: any): obj is Halo2Error_ {
      return obj.tag === MoproError_Tags.Halo2Error;
    }

    static hasInner(obj: any): obj is Halo2Error_ {
      return Halo2Error_.instanceOf(obj);
    }

    static getInner(obj: Halo2Error_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type NoirError__interface = {
    tag: MoproError_Tags.NoirError;
    inner: Readonly<[string]>;
  };

  class NoirError_ extends UniffiError implements NoirError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'MoproError';
    readonly tag = MoproError_Tags.NoirError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('MoproError', 'NoirError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): NoirError_ {
      return new NoirError_(v0);
    }

    static instanceOf(obj: any): obj is NoirError_ {
      return obj.tag === MoproError_Tags.NoirError;
    }

    static hasInner(obj: any): obj is NoirError_ {
      return NoirError_.instanceOf(obj);
    }

    static getInner(obj: NoirError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is MoproError {
    return obj[uniffiTypeNameSymbol] === 'MoproError';
  }

  return Object.freeze({
    instanceOf,
    CircomError: CircomError_,
    Halo2Error: Halo2Error_,
    NoirError: NoirError_,
  });
})();

export type MoproError = InstanceType<
  (typeof MoproError)[keyof Omit<typeof MoproError, 'instanceOf'>]
>;

// FfiConverter for enum MoproError
const FfiConverterTypeMoproError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = MoproError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new MoproError.CircomError(FfiConverterString.read(from));
        case 2:
          return new MoproError.Halo2Error(FfiConverterString.read(from));
        case 3:
          return new MoproError.NoirError(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case MoproError_Tags.CircomError: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case MoproError_Tags.Halo2Error: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case MoproError_Tags.NoirError: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that MoproError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case MoproError_Tags.CircomError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case MoproError_Tags.Halo2Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case MoproError_Tags.NoirError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum ProofLib {
  Arkworks,
  Rapidsnark,
}

const FfiConverterTypeProofLib = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ProofLib;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ProofLib.Arkworks;
        case 2:
          return ProofLib.Rapidsnark;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ProofLib.Arkworks:
          return ordinalConverter.write(1, into);
        case ProofLib.Rapidsnark:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterArrayString
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_mopro_example_app_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_generate_circom_proof() !==
    27552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_generate_circom_proof'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_generate_halo2_proof() !==
    51520
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_generate_halo2_proof'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_generate_noir_proof() !==
    27260
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_generate_noir_proof'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_get_noir_verification_key() !==
    19747
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_get_noir_verification_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_mopro_hello_world() !==
    8816
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_mopro_hello_world'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_verify_circom_proof() !==
    8858
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_verify_circom_proof'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_verify_halo2_proof() !==
    142
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_verify_halo2_proof'
    );
  }
  if (
    nativeModule().ubrn_uniffi_mopro_example_app_checksum_func_verify_noir_proof() !==
    56869
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_mopro_example_app_checksum_func_verify_noir_proof'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCircomProof,
    FfiConverterTypeCircomProofResult,
    FfiConverterTypeG1,
    FfiConverterTypeG2,
    FfiConverterTypeHalo2ProofResult,
    FfiConverterTypeMoproError,
    FfiConverterTypeProofLib,
  },
});
